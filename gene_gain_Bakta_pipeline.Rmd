---
title: "gene_gain_Bakta_pipeline"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load packages.
```{r}
library(tidyverse)
# BiocManager::install(c("GenomicRanges", "rtracklayer", "Gviz"))
library(rtracklayer)
library(GenomicRanges)
library(Gviz)
```


We want to find potential genes gained in derived isolates, which are genes present in the derived isolates but absent in its most probable ancestor. There are 26 most probable ancestors, so there are 26 groups containing one most probable ancestor and its descendants. We perform gene presence and absence analysis for each group using Panaroo.



The three files generated by Panaroo will be used for investigate genes gained in derived isolates. More information about file format can be found on <https://sanger-pathogens.github.io/Roary/> and <https://gthlab.au/panaroo/#/gettingstarted/output>).

1.**gene_presence_absence.csv** 
- **Gene**: the most frequently occurring gene name from the sequences in the cluster. If there is no gene name, then it is given a generic unique name group_XXX. 
- **Non unique gene name**: sequences with the same gene name have ended up in different groups. It might be because of split genes, or miss annotation. 
- **Annotation**: most frequently occurring functional annotation from the cluster. Annotations that have been merged will be separated by a semicolon. 
- **Rest of columns with sample names**: Presence and absence of gene clusters in each sample. If a gene cluster is present in a sample, the sequence name of the representative for that sample is given in the matrix. Some entry has two annotation ids separated by semicolon. These are fragmented gene merged by Panaroo (See this post: <https://github.com/gtonkinhill/panaroo/issues/257>).

2. **gene_presence_absence.Rtab**
    -   tab delimited binary matrix with the presence and absence of each gene in each sample. 1 indicates the gene is present in the sample, a 0 indicates it is absent.

3. **gene_data.csv**
    -   It links each gene sequence and annotation to the internal representations used.
    -   **clustering_id**: internal gene name used by Panaroo.
    -   **annotation_id**: original gene ID produced from annotation program, such as Bakta. Same annotation id may appear multiple times across samples, so it is best to include sample name in annotation id to make it unique. If the gene is refound by Panaroo, it has the same clustering_id and annotation_id as "XX_refound_XX".






Load Panaroo's output files. This will make a list with 26 lists, each with 3 data frames of the 3 files above.
```{r}
panaroo_output <- vector("list", length(list.files(path = "../output/gene_gain_loss_Bakta_pipeline", pattern="_panaroo_output")))
names(panaroo_output) <- list.files(path = "../output/gene_gain_loss_Bakta_pipeline", pattern="_panaroo_output")

for (i in seq_along(panaroo_output)) {
  panaroo_output[[i]] <- vector("list", length=3)
  names(panaroo_output[[i]]) <- c("gene_pre_abs_csv", "gene_pre_abs_tab", "gene_data_csv")
  
  panaroo_output[[i]]$gene_pre_abs_csv <- read.csv(paste0("../output/gene_gain_loss_Bakta_pipeline/", names(panaroo_output)[i], "/gene_presence_absence.csv"), header=TRUE) %>%
    rename(gene=Gene, non_unique_gene_name=Non.unique.Gene.name, annotation=Annotation) #use lowercase for column names
  
  panaroo_output[[i]]$gene_pre_abs_tab <- read.table(paste0("../output/gene_gain_loss_Bakta_pipeline/", names(panaroo_output)[i], "/gene_presence_absence.Rtab"), header=TRUE) %>%
  rename(gene=Gene) #use lowercase for column name
  
  panaroo_output[[i]]$gene_data_csv <- read.csv(paste0("../output/gene_gain_loss_Bakta_pipeline/", names(panaroo_output)[i], "/gene_data.csv"), header=TRUE)
}
```




Find genes gained and store intermediate and final results in a list. 

Each object in the list will contain 5 data frames: 
1. **mpa_gene_pre_abs**: presence and absence data of most probable ancestors, generated from gene_presence_absence.Rtab. 

2.**derived_gene_pre_abs**: presence and absence data of derived isolates, generated from gene_presence_absence.Rtab.

3. **joined_gene_pre_abs**: combined presence and absence data of both most probable ancestors and derived isolates from **mpa_gene_pre_abs** and **derived_gene_pre_abs**, with annotations added from gene_presence_absence.csv.

4. **pgap_annot_id**: annotation id of each gene group and isolate, generated from gene_presence_absence.csv.

5. **genes_gained**: genes present in derived isolate but not in its corresponding most probable ancestor, with annotation id added from **pgap_annot_id** and DNA sequence of each annotation added from gene_data.csv.



Make a list with 26 lists, each with 5 data frames as described above.
```{r}
gene_gain <- vector("list", length=length(panaroo_output))
names(gene_gain) <- str_replace(names(panaroo_output), "_panaroo_output", "_gene_gain")

for (i in seq_along(gene_gain)) {
  #in each object of the list, make 5 empty data frames for input later
  gene_gain[[i]] <- vector("list", length=5)
  names(gene_gain[[i]]) <- c("pgap_annot_id", "mpa_gene_pre_abs", "derived_gene_pre_abs", "joined_gene_pre_abs", "genes_gained")
  
  #1. data frame for presence and absence data for most probable ancestors
  gene_gain[[i]]$mpa_gene_pre_abs <- panaroo_output[[i]]$gene_pre_abs_tab %>%
    pivot_longer(cols = c(2:ncol(.)), names_to = "MPA", values_to = "MPA_pre_abs") %>%
    filter(grepl("Rht", MPA, fixed = FALSE)) #select MPA
  
  #2. data frame for presence and absence data for derived isolates
  gene_gain[[i]]$derived_gene_pre_abs <- panaroo_output[[i]]$gene_pre_abs_tab %>%
    pivot_longer(cols = c(2:ncol(.)), names_to = "derived", values_to = "derived_pre_abs") %>%
    filter(!grepl("Rht", derived, fixed = FALSE)) %>% #select derived isolate
    mutate(derived = str_extract(derived, "[:digit:]+_[:digit:]+_[:alnum:]+")) #rename isolate
  
  #3. joined data frame combining presence and absence data for most probable ancestors and derived isolates, with annotation joined for each gene group
  gene_gain[[i]]$joined_gene_pre_abs <- gene_gain[[i]]$derived_gene_pre_abs %>%
    left_join(gene_gain[[i]]$mpa_gene_pre_abs, by = "gene") %>%
    left_join(panaroo_output[[i]]$gene_pre_abs_csv[,c("gene","non_unique_gene_name","annotation")], by = "gene") #add annotation
  
  #4. data frame for pgap annotation id for each gene group
  gene_gain[[i]]$pgap_annot_id <- panaroo_output[[i]]$gene_pre_abs_csv %>%
    pivot_longer(cols = c(4:ncol(.)), names_to = "isolate", values_to = "annotation_id") %>%
    mutate(isolate = ifelse(str_detect(isolate, "Rht"), 
                            isolate, 
                            str_extract(isolate, "[:digit:]+_[:digit:]+_[:alnum:]+"))) #clean the name of derived isolate
  
  #5. data frame with genes gained
  gene_gain[[i]]$genes_gained <- gene_gain[[i]]$joined_gene_pre_abs %>%
    filter(derived_pre_abs == 1 & MPA_pre_abs == 0) %>% #select genes gained (1 in isolate, 0 in MPA)
    left_join(gene_gain[[i]]$pgap_annot_id[,c("gene", "isolate", "annotation_id")], by=c("gene"="gene", "derived"="isolate")) %>% #join annotation id by gene group and derived isolate (only need to join by derived isolate because MPA does not have annotation id for genes gained) 
    mutate(annotation_id = str_remove_all(annotation_id, "_pseudo")) %>% #remove "_pseudo" from annotation id for matching as gene_data_csv does not has this
    left_join(panaroo_output[[i]]$gene_data_csv[,c("gff_file", "annotation_id", "dna_sequence", "description")], by = c("derived"="gff_file", "annotation_id"="annotation_id")) %>% #add DNA sequence
    mutate(annotation_id = paste(derived, annotation_id, sep = "-")) #include derived isolate name in pgap annotation id
}
```





Make sure annotation id is unique.
```{r}
for (i in seq_along(gene_gain)) {
  print(gene_gain[[i]]$genes_gained$annotation_id[duplicated(gene_gain[[i]]$genes_gained$annotation_id)])
}
#no duplicate, annotation id is unique 
```



How many genes gained (annotation id) in each of the 26 groups of MPA and its descendants. 
```{r}
for (i in seq_along(gene_gain)) {
  num_genes_gained <- nrow(gene_gain[[i]]$genes_gained) #each row is a unique gene annotation
  cat("The derived isolates with", str_extract(names(gene_gain)[i], "Rht_[:digit:]+_(N|C)"), "as their most probable ancestor have", num_genes_gained, "annotations identified as gene gain. \n")
} 
#The following 4 groups have 0 genes gained: Rht_074_C, Rht_097_N, Rht_116_N, Rht_596_N
```



Are there merged pgap annotation ids (e.g. cds-pgaptmp_007112;cds-pgaptmp_002878)? The joining function could fail if there are merged annotation ids in the annotation_id column, causing no DNA sequence for these annotation ids.
```{r}
for (i in seq_along(gene_gain)) {
  print(names(gene_gain)[i])
  print(gene_gain[[i]]$genes_gained$annotation_id[str_detect(gene_gain[[i]]$genes_gained$annotation_id, ";")])
}
```




Skip this chunk: Separate the two merged annotation ids for Rht_460_C.
```{r fix merged annotation id problem}
#reformat the genes_gained data frame for Rht_460_C
# gene_gain$`Rht_460_C-gene-gain-analysis`$genes_gained <- gene_gain[["Rht_460_C-gene-gain-analysis"]]$joined_gene_pre_abs %>%
#   filter(derived_pre_abs == 1 & MPA_pre_abs == 0) %>%
#   left_join(gene_gain[["Rht_460_C-gene-gain-analysis"]]$pgap_annot_id[,c("gene", "isolate", "annotation_id")], by = c("gene"="gene", "derived"="isolate")) %>%
#   mutate(annotation_id = str_remove_all(annotation_id, "_pseudo")) %>%
#   
#   #separate the merged annotation ids
#   separate(col=annotation_id, into=c("annotation_id1", "annotation_id2"), sep=";") %>%
#   pivot_longer(cols=c("annotation_id1", "annotation_id2"), names_to="id", values_to = "annotation_id") %>%
#   drop_na(annotation_id) %>%
#   dplyr::select(-id) %>%
#   
#   left_join(panaroo_output[["Rht_460_C-pav-analysis"]]$gene_data_csv[,c("gff_file", "annotation_id", "dna_sequence", "description")], by = c("derived"="gff_file", "annotation_id"="annotation_id")) %>%
#    mutate(annotation_id = paste(derived, annotation_id, sep = "_"))
# 
# #Check merged annotation ids
# for (i in seq_along(gene_gain)) {
#   print(gene_gain[[i]]$genes_gained$annotation_id[str_detect(gene_gain[[i]]$genes_gained$annotation_id, ";")])
# }
#no merged annotation ids found. 
```

Skip: Compare similarity of DNA sequences of the two pairs of merged annotation ids.
```{r check DNA sequences of merged annotation ids}
#first pair: 16_1_7_cds-pgaptmp_007176;cds-pgaptmp_007175 
# isolate_16_1_7_cds_pgaptmp_007176 <- subset(gene_gain$`Rht_460_C-gene-gain-analysis`$genes_gained, 
#                                             annotation_id == "16_1_7_cds-pgaptmp_007176")$dna_sequence
# 
# isolate_16_1_7_cds_pgaptmp_007175 <- subset(gene_gain$`Rht_460_C-gene-gain-analysis`$genes_gained,
#                                             annotation_id == "16_1_7_cds-pgaptmp_007175")$dna_sequence
# 
# str_length(isolate_16_1_7_cds_pgaptmp_007176)
# str_length(isolate_16_1_7_cds_pgaptmp_007175)
# #both are 138 bp 
# 
# sum(str_split_1(isolate_16_1_7_cds_pgaptmp_007176, "") == str_split_1(isolate_16_1_7_cds_pgaptmp_007175, ""))
# #137 positions with the same bases, 1 position with mismatch
# 
# #second pair: 9_2_1_cds-pgaptmp_007255;cds-pgaptmp_000001 
# isolate_9_2_1_cds_pgaptmp_007255 <- subset(gene_gain$`Rht_460_C-gene-gain-analysis`$genes_gained, 
#                                            annotation_id == "9_2_1_cds-pgaptmp_007255")$dna_sequence
# 
# isolate_9_2_1_cds_pgaptmp_000001 <- subset(gene_gain$`Rht_460_C-gene-gain-analysis`$genes_gained, 
#                                            annotation_id == "9_2_1_cds-pgaptmp_000001")$dna_sequence
# 
# str_length(isolate_9_2_1_cds_pgaptmp_007255)
# str_length(isolate_9_2_1_cds_pgaptmp_000001)
# #both are 138 bp
# 
# sum(str_split_1(isolate_9_2_1_cds_pgaptmp_007255, "") == str_split_1(isolate_9_2_1_cds_pgaptmp_000001, ""))
#137 positions with the same bases, 1 position with mismatch
```



To find where these genes gained coming from, for each of the 22 FASTA files, use it as query to perform BLAST alignment against each of the 56 genomes of the ancestral isolates. There are $$19\times56=1064$$ BLAST output files.




Export the DNA sequences in FASTA format with annotation id as the name of the sequence. 
```{r}
gene_gain_seq <- vector("list", length=length(gene_gain))
names(gene_gain_seq) <- str_replace(names(gene_gain), "_gene_gain", "_gene_gain_seq")

for (i in seq_along(gene_gain_seq)) {
  if (nrow(gene_gain[[i]]$genes_gained) != 0) { #skip files with no genes gained
      gene_gain_seq[[i]] <- vector("list", length=2)
  names(gene_gain_seq[[i]]) <- c("sequence_name", "fasta_sequence")
  
  gene_gain_seq[[i]]$sequence_name <- paste0(">", gene_gain[[i]]$genes_gained$annotation_id)
  
  gene_gain_seq[[i]]$fasta_sequence <- c(rbind(gene_gain_seq[[i]]$sequence_name, gene_gain[[i]]$genes_gained$dna_sequence))
  
  mpa <- str_extract(names(gene_gain_seq)[i], "Rht_[:digit:]+_(N|C)")
  
  write(x = gene_gain_seq[[i]]$fasta_sequence, file = paste0("../output/gene_gain_loss_Bakta_pipeline/", mpa, "_gene_gain.fasta"))
  }
}
#22 FASTA files after ignoring the 4 groups with no genes gained
```





We want to find which ancestral strains give the genes gained in derived isolates and exclude false genes gained (genes that are present both derived isolates and ancestral strains).

Perform BLAST alignment with genes gained as query and each of the 56 ancestral strains as reference. There should be $$22\times56=1232$$ BLAST output files.


BLAST's output will contain the following information about the alignment:
- qacc (Query accession)
- qlen (Query sequence length) 
- sacc (Subject accession) 
- slen (Subject sequence length) 
- qstart (Start of alignment in query) 
- qend (End of alignment in query) 
- sstart (Start of alignment in subject) 
- send (End of alignment in subject) 
- evalue (Expect value) 
- bitscore (Bit score) 
- length (Alignment length) 
- pident (Percentage of identical matches) 
- nident (Number of identical matches) 
- mismatch (Number of mismatches) 
- gapopen (Number of gap openings) 
- gaps (Total number of gaps) 
- sstrand (Subject Strand) 
- qcovs (Query Coverage Per Subject) 
- qcovhsp (Query Coverage Per HSP) 
- qcovus (Query Coverage Per Unique Subject (blastn only))




Load BLAST alignment results. This will generate a list with 22 lists, each with 56 data frames.
```{r}
mpa <- list.files(path="../output/gene_gain_loss_Bakta_pipeline/gene_gain_blast_output")
mpa <- unique(str_extract(mpa, "MPA_Rht_[:digit:]+_(N|C)"))

gene_gain_blast_output <- vector("list", length=length(mpa))
names(gene_gain_blast_output) <- mpa

for (i in seq_along(gene_gain_blast_output)) { 
  #make a list with 56 data frames in each of 22 MPAs
  gene_gain_blast_output[[i]] <- vector("list", length=56) 
  
  names(gene_gain_blast_output[[i]]) <- list.files(path = "../output/gene_gain_loss_Bakta_pipeline/gene_gain_blast_output", pattern = mpa[i])
  
  for (j in seq_along(gene_gain_blast_output[[i]])) { 
    #load BLAST output files as data frame
    gene_gain_blast_output[[i]][[j]] <- read.csv(paste0("../output/gene_gain_loss_Bakta_pipeline/gene_gain_blast_output/", names(gene_gain_blast_output[[i]])[j]), header=TRUE)
    
    #add ancestral isolate name as a column to each data frame
    if (nrow(gene_gain_blast_output[[i]][[j]] > 0)) { #skip files with no hits
      gene_gain_blast_output[[i]][[j]] <- cbind(subject=str_extract_all(names(gene_gain_blast_output[[i]])[[j]], "Rht_[:digit:]+_(N|C)", simplify=TRUE)[1,2], gene_gain_blast_output[[i]][[j]])
      
      gene_gain_blast_output[[i]][[j]] <- cbind(MPA=str_extract_all(names(gene_gain_blast_output[[i]])[[j]], "Rht_[:digit:]+_(N|C)", simplify=TRUE)[1,1], gene_gain_blast_output[[i]][[j]])
    } 
  }
}
```


Merge the 56 data frames in each list to 1 data frame.
```{r}
gene_gain_blast_output2 <- vector("list", length=length(gene_gain_blast_output))
names(gene_gain_blast_output2) <- names(gene_gain_blast_output)

for (i in seq_along(gene_gain_blast_output2)) {
  gene_gain_blast_output2[[i]] <- Filter(function(df) nrow(df)>0, gene_gain_blast_output[[i]]) #remove data frames with no hits
  gene_gain_blast_output2[[i]] <- Reduce(function(df1,df2) bind_rows(df1,df2), gene_gain_blast_output2[[i]]) #bind rows for all data frame in each of 22 lists
}
```



Find false genes gained. A gene gained is false if it has a BLAST hit in its most probable ancestor (rows which MPA is the same as subject). 


Make a data frame for false genes gained. We will investigate what might cause these misidentifications later. 
```{r}
false_gene_gain <- vector("list", length=length(gene_gain_blast_output2))
names(false_gene_gain) <- names(gene_gain_blast_output2)

for (i in seq_along(gene_gain_blast_output2)) {
  false_gene_gain[[i]] <- gene_gain_blast_output2[[i]] %>%
    group_by(qacc) %>% 
    mutate(false_genes_gained = ifelse(unique(MPA) %in% subject, "Yes", "No")) %>% # if MPA is the same as subject, the query is a false gene gained.
    filter(false_genes_gained == "Yes")
}

false_gene_gain2 <- Reduce(function(df1,df2) bind_rows(df1,df2), false_gene_gain) # merge data frames

false_gene_gain2 <- filter(false_gene_gain2, MPA==subject) # keep rows when MPA is the same as subject
```



Also make a data frame for true genes gained.
```{r}
#make a list to store results after removing false positive results
true_gene_gain <- vector("list", length=length(gene_gain_blast_output2))
names(true_gene_gain) <- names(gene_gain_blast_output2)

for (i in seq_along(gene_gain_blast_output2)) {
  true_gene_gain[[i]] <- gene_gain_blast_output2[[i]] %>%
    group_by(qacc) %>%
    mutate(false_genes_gained = ifelse(unique(MPA) %in% subject, "Yes", "No")) %>%
    filter(false_genes_gained == "No")
}

true_gene_gain <- Filter(function(df) nrow(df)>0, true_gene_gain) # remove empty data frames

true_gene_gain <- Reduce(function(df1,df2) bind_rows(df1,df2), true_gene_gain) # merge data frames
```



How many true genes gained?
```{r}
length(unique(true_gene_gain$qacc))
# 83 true genes gained
```


Which derived isolates have the genes gained?
```{r}
unique(str_extract(true_gene_gain$qacc, "[:digit:]+_[:digit:]+_[:alnum:]+"))
# "19_2_1" "15_2_7"
```                                  



Which scaffolds the genes gained are on? 
```{r}
true_gene_gain[,c("derived_isolate", "annotation_id")] <- do.call(rbind, strsplit(true_gene_gain$qacc, "-"))

true_gene_gain2 <- true_gene_gain[,c("derived_isolate", "annotation_id")]

true_gene_gain2 <- distinct(true_gene_gain2) # a data frame with annotation of genes gained and corresponding derived isolate 


# load gene data
Rht_108_C_gene_data <- read.csv("../output/gene_gain_loss_Bakta_pipeline/Rht_108_C_panaroo_output/gene_data.csv")

Rht_861_C_gene_data <- read.csv("../output/gene_gain_loss_Bakta_pipeline/Rht_861_C_panaroo_output/gene_data.csv")

# annotation data for genes gained
Rht_108_C_gene_gain <- subset(Rht_108_C_gene_data, gff_file %in% true_gene_gain2$derived_isolate & 
                            annotation_id %in% true_gene_gain2$annotation_id)

Rht_861_C_gene_gain <- subset(Rht_861_C_gene_data, gff_file %in% true_gene_gain2$derived_isolate & 
                            annotation_id %in% true_gene_gain2$annotation_id) 

# which scaffolds have the genes gained
unique(with(Rht_108_C_gene_gain, paste0(gff_file, "-", scaffold_name)))

unique(with(Rht_861_C_gene_gain, paste0(gff_file, "-", scaffold_name)))

# "19_2_1-NODE_6_length_453614_cov_40.619392"  "15_2_7-NODE_1_length_1058762_cov_34.058254"
```



Make a figure with all annotations of the scaffold with genes gained. 


Load annotations of the two derived isolates.
```{r}
annot_19_2_1 <- rtracklayer::import.gff3("../output/gene_gain_loss_Bakta_pipeline/gene_annotation/19_2_1-scaffolds.gff3")

annot_15_2_7 <- rtracklayer::import.gff3("../output/gene_gain_loss_Bakta_pipeline/gene_annotation/15_2_7-scaffolds.gff3")
```

Extract the scaffolds with genes gained.
```{r}
annot_scaffold_1_15_2_7 <- annot_15_2_7[seqnames(annot_15_2_7) == "NODE_1_length_1058762_cov_34.058254"]

annot_gene_gain_15_2_7 <- annot_scaffold_1_15_2_7[mcols(annot_scaffold_1_15_2_7)$ID %in% Rht_861_C_gene_gain$annotation_id] # only keep the genes gained


annot_scaffold_6_19_2_1 <- annot_19_2_1[seqnames(annot_19_2_1) == "NODE_6_length_453614_cov_40.619392"]

annot_gene_gain_19_2_1 <- annot_scaffold_6_19_2_1[mcols(annot_scaffold_6_19_2_1)$ID %in% Rht_108_C_gene_gain$annotation_id] # only keep the genes gained
```

Plot annotations of genes gained of 15_2_7
```{r}
# disable the UCSC's chromosome naming format (chromosome must start with 'chr')
options(ucscChromosomeNames=FALSE)

annotTrack_gene_gain_15_2_7 <- Gviz::AnnotationTrack(start = start(annot_gene_gain_15_2_7),
                                               width = width(annot_gene_gain_15_2_7),
                                               chromosome = seqnames(annot_gene_gain_15_2_7),
                                               strand = strand(annot_gene_gain_15_2_7),
                                               id = mcols(annot_gene_gain_15_2_7)$product,
                                               genome = "15_2_7",
                                               name = "82 genes gained in 15_2_7",
                                               rotation.item = 90,
                                               col = "#000000",
                                               fontcolor.item = "#FF0000")

axisTrack_gene_gain_15_2_7 <- Gviz::GenomeAxisTrack(range = IRanges(start = start(annot_gene_gain_15_2_7),
                                      width = width(annot_gene_gain_15_2_7)))

Gviz::plotTracks(c(annotTrack_gene_gain_15_2_7, axisTrack_gene_gain_15_2_7), 
                 featureAnnotation = "id",
                 add53 = TRUE, add35 = TRUE)
```


Plot annotation of gene gained of 19_2_1. Since there is only one gene gained, also plot nearby genes. 


Find nearby genes around the gene gained
```{r}
annot_gene_gain_19_2_1

annot_19_2_1


```

```{r}
# disable the UCSC's naming format (chromosome must start with 'chr')
options(ucscChromosomeNames=FALSE)

annotTrack_gene_gain_19_2_1 <- Gviz::AnnotationTrack(start = start(annot_gene_gain_19_2_1),
                                               width = width(annot_gene_gain_19_2_1),
                                               chromosome = seqnames(annot_gene_gain_19_2_1),
                                               strand = strand(annot_gene_gain_19_2_1),
                                               id = mcols(annot_gene_gain_19_2_1)$product,
                                               genome = "19_2_1",
                                               name = "1 gene gained in 19_2_1",
                                               col = "#000000",
                                               fontcolor.item = "#FF0000")

axisTrack_gene_gain_19_2_1 <- Gviz::GenomeAxisTrack(range = IRanges(start = start(annot_gene_gain_19_2_1),
                                      width = width(annot_gene_gain_19_2_1)))

Gviz::plotTracks(c(annotTrack_gene_gain_19_2_1, axisTrack_gene_gain_19_2_1), 
                 featureAnnotation = "id",
                 add53 = TRUE, add35 = TRUE)
```


# Below is old code. 





Check files with no hits found
```{r}
# no_hits <- character()
# for (i in seq_along(gene_gain_blast_output)) {
#   for (j in seq_along(gene_gain_blast_output[[i]]))
#     if (nrow(gene_gain_blast_output[[i]][[j]]) == 0) {
#       no_hits <- c(names(gene_gain_blast_output[[i]])[j], no_hits)
#     }
# }
# no_hits
```











We decide that when a gene gained has **any hits** in the most probable ancestor regardless of the hits it has in other ancestral isolates, it is a false gene gained.

Some possible causes of false positive genes gained: 
- A gene in the derived isolate and most probable ancestor have very different lengths due to incomplete genome assembly. Panaroo treats them as different genes although they have identical sequences. 
- A gene recorded as gain is aligned to unannotated region in the most probable ancestor.

Check the complete length of gene in the most probable ancestor the false positive genes gained are aligned to. Check whether all false positive genes gained can align to the annotated region. These can done by finding overlapping regions between false positive genes gained and genome annotation with the "GenomicRanges" bioconductor package.

Prepare GRanges object of false positive BLAST hits. Note that strand is relative in BLAST. When query and subject are on the same strand, both are plus strands. When query and subject are on the opposite strand, query is plus strand and subject is minus strand (<https://support.nlm.nih.gov/kbArticle/?pn=KA-05225>).


```{r check false postive genes gained: GRanges for false positive genes gained}
#make a list for false positive genes gained
fal_pos_blast_hits <- vector("list", length=length(blast_output_merged))
names(fal_pos_blast_hits) <- names(blast_output_merged)

for (i in seq_along(blast_output_merged)) {
  fal_pos_blast_hits[[i]] <- blast_output_merged[[i]] %>%
    group_by(qacc) %>%
    mutate(false_positive = ifelse(unique(blast_output_merged[[i]]$MPA) %in% subject, "Yes", "No")) %>% 
    filter(false_positive == "Yes")
}

#merge all data frames in the list to one data frame
fal_pos_blast_hits_df <- Reduce(function(df1,df2) bind_rows(df1,df2), fal_pos_blast_hits)

#only keep hits that are in the most probable ancestor, when subject is the MPA.
fal_pos_blast_hits_df <- filter(fal_pos_blast_hits_df, MPA==subject)

#index each row with row number starting from 1
fal_pos_blast_hits_df <- cbind(index=as.numeric(rownames(fal_pos_blast_hits_df)), fal_pos_blast_hits_df)

#finding overlaps requires the start position is smaller than the end position. Reverse the positions when start position is larger than the end position (query and subject are on opposite strand)
fal_pos_blast_hits_df$start_end <- with(fal_pos_blast_hits_df, ifelse(sstart>send, paste0(send,",",sstart), paste0(sstart,",",send)))

fal_pos_blast_hits_df <- separate(fal_pos_blast_hits_df, col=start_end, into=c("sstart2", "send2"), sep=",", convert=TRUE)

#both GenomicRanges and BLAST use 1-based coordinate system for range (closed intervals, both the start and end positions are included in the range, range width = end - start + 1)
fal_pos_blast_hits_df$scaffold <- paste0(fal_pos_blast_hits_df$subject, "_", fal_pos_blast_hits_df$sacc) #rename the chromosome/plasmids (subject accession in BLAST) to include the ancestral isolate name (the subject in BLAST)

fal_pos_blast_hits_gr <- GRanges(seqnames=fal_pos_blast_hits_df$scaffold,
                                ranges=IRanges(start=fal_pos_blast_hits_df$sstart2,
                                               end=fal_pos_blast_hits_df$send2)) 
```

Some plots for false positive genes gained: query sequence length, expect value, percentage of identical matches.
```{r}
#number of occurrences of each false positive hits
fal_pos_blast_hits_df %>%
  count(qacc) %>%
  ggplot(aes(x=qacc, y=n)) +
  geom_col(fill="grey", colour="black") +
  xlab("annotation id") +
  ylab("count of occurrences") +
  theme_bw() +
  theme(axis.text.x=element_blank()) 
#each false positive annotation id has more than 1 hits in most probable ancestor

#distribution of query sequence length
ggplot(data=fal_pos_blast_hits_df, aes(x=qlen)) +
  geom_histogram(fill="grey", colour="black", binwidth=1) +
  xlab("query sequence length (bp)") +
  ylab("number of hits") +
  theme_bw()

summary(fal_pos_blast_hits_df$qlen)

#distribution of expect value
ggplot(data=fal_pos_blast_hits_df, aes(x=evalue)) +
  geom_histogram(fill="grey", colour="black", binwidth=1e-10) +
  xlab("expect value") +
  ylab("number of hits") +
  theme_bw()

#distribution of percentage of identical matches
ggplot(data=fal_pos_blast_hits_df, aes(x=pident)) +
  geom_histogram(fill="grey", colour="black", binwidth=1) +
  xlab("percentage of identical matches (%)") +
  ylab("number of hits") +
  theme_bw()
```

Prepare GRanges object of annotation of the 26 most probable ancestors.
```{r}
#load annotation files of most probable ancestors (26 files)
mpa_annot <- vector("list", length=length(list.files(path = "./gene_gain_loss_analysis/pgap_method/mpa_annotation"))) 
names(mpa_annot) <- list.files(path = "./gene_gain_loss_analysis/pgap_method/mpa_annotation")

for (i in 1:length(mpa_annot)) {
  mpa_annot[[i]] <- rtracklayer::import.gff3(paste0("./gene_gain_loss_analysis/pgap_method/mpa_annotation/", names(mpa_annot[i])))
}

#include the isolate name in chromosome/plasmid name to make it unique across isolates
mpa_name <- str_extract(names(mpa_annot), "Rht_[:digit:]+_(N|C)")
for (i in seq_along(mpa_annot)) {
  seqlevels(mpa_annot[[i]]) <- unique(paste0(mpa_name[i], "_", seqnames(mpa_annot[[i]])))
}

#in the "type" column, feature type labelled with "region" is the entire range of chromosome/plasmid. Remove this type of range. 
for (i in seq_along(mpa_annot)) {
  mpa_annot[[i]] <- mpa_annot[[i]][mcols(mpa_annot[[i]])$type != "region"]
}

#combine all 26 GRanges objects to 1 GRangesList object
mpa_annot_grl <- GRangesList(mpa_annot)

#unlist GRangesList object to a GRanges object
mpa_annot_gr <- unlist(mpa_annot_grl)

#check scaffold names: combination of isolate name and chromosome/plasmids name
seqlevels(mpa_annot_gr)

#check how many unique ranges
length(mpa_annot_gr[!GenomicRanges::duplicated(mpa_annot_gr)]) #187831 

#remove duplicated ranges 
mpa_annot_gr <- mpa_annot_gr[!GenomicRanges::duplicated(mpa_annot_gr)]
#mpa_annot_gr <- mpa_annot_gr[mcols(mpa_annot_gr)$type != "pseudogene"]

#make it a data frame from GRanges object for later use
names(mpa_annot_gr) <- 1:length(mpa_annot_gr)

mpa_annot_df <- as.data.frame(mpa_annot_gr)

#index each row with row number
mpa_annot_df <- cbind(index=as.numeric(rownames(mpa_annot_df)), mpa_annot_df)
```

Find overlaps between false positive hits and genomic annotations. Use false positive hits gained as query and annotation as subject.

```{r}
#because strand is relative in BLAST result, ignore strand when finding overlaps
fal_pos_overlaps <- as.data.frame(GenomicRanges::findOverlaps(query=fal_pos_blast_hits_gr,
                                                              subject=mpa_annot_gr,
                                                              ignore.strand=TRUE)) 
 
#join annotation of most probable ancestors
fal_pos_overlaps <- left_join(fal_pos_overlaps, mpa_annot_df, by=c("subjectHits"="index"))

#join false positive genes gained
fal_pos_overlaps <- left_join(fal_pos_overlaps, fal_pos_blast_hits_df, by=c("queryHits"="index"))

#relocate the following columns of start and end positions of query ranges (false positive BLAST hits)
fal_pos_overlaps <- dplyr::relocate(fal_pos_overlaps, sstart2, .after=end)
fal_pos_overlaps <- dplyr::relocate(fal_pos_overlaps, send2, .after=sstart2)
```

Do all false positive BLAST hits have at least one overlaps?

```{r}
fal_pos_blast_hits_df$have_overlap <- ifelse(fal_pos_blast_hits_df$index %in% fal_pos_overlaps$queryHits, "Yes", "No")

table(fal_pos_blast_hits_df$have_overlap)
#out of a total of 13012 false positive hits, 12804 have overlaps with annotations, and 208 do not have overlaps.
```

What are the widths of the genes the false positive BLAST hits overlap with

```{r}
ggplot(data=fal_pos_overlaps, aes(x=width)) +
  geom_histogram(fill="grey", colour="black", binwidth=1) +
  xlab("width (bp)") +
  ylab("Number of overlaps") +
  theme_bw()

summary(fal_pos_overlaps$width)
```

Remove false positive genes gained.

```{r remove false positive genes gained}
#only keep hits that are in the most probable ancestor, when subject is the MPA.
fal_pos_blast_hits_df <- filter(fal_pos_blast_hits_df, MPA==subject)

#make a list to store results after removing false positive results
true_gene_gain <- vector("list", length=length(blast_output_merged))
names(true_gene_gain) <- names(blast_output_merged)

for (i in seq_along(blast_output_merged)) {
  true_gene_gain[[i]] <- blast_output_merged[[i]] %>%
    group_by(qacc) %>%
    mutate(false_positive = ifelse(unique(blast_output_merged[[i]]$MPA) %in% subject, "Yes", "No")) %>%
    filter(false_positive == "No")
}

#merge to one data frame
true_gene_gain <- Filter(function(df) nrow(df)>0, true_gene_gain) #remove data frames with no hits

true_gene_gain_df <- Reduce(function(df1,df2) bind_rows(df1,df2), true_gene_gain) 

#add metadata of ancestral isolate's community and derived isolate's treatment
metadata_ancestral_isolates <- read.csv("./MPA_data/2008strains.csv")  %>%
  dplyr::select(anc_name, community)

metadata_derived_isolates <- read.csv("./MPA_data/metadata_363EE2008isolates.csv") %>%
  dplyr::select(sample_ID_seq, Treatment) %>% #keep columns of interest
  mutate(sample_ID_seq = gsub("[[:space:]]", "", sample_ID_seq)) #remove white space

true_gene_gain_df <- true_gene_gain_df %>%
  mutate(derived_isolate=str_extract(qacc, "[:digit:]+_[:digit:]+_[:alnum:]+"), .after=subject) %>%
  left_join(metadata_ancestral_isolates, by=c("subject"="anc_name")) %>% #add community where subject is assigned to
  left_join(metadata_derived_isolates, by=c("derived_isolate"="sample_ID_seq")) %>% #add treatment of derived isolate
  mutate(Treatment = str_extract(Treatment, "[:alpha:]+"), #rename the two populations to be consistent
         community = case_when(community == "control, mixed" ~ "control and mixed",
                               community == "N-adapted, mixed" ~ "N and mixed",
                               community == "control" ~ "control",
                               community == "N-adapted" ~ "N")) %>%
  rowwise() %>%
  mutate(match = grepl(Treatment, community)) #match between community and treatment
```

Number of genes gained, which isolates have the genes gained.

```{r genes gained}
#number of unique pgap annotation ids
unique(true_gene_gain_df$qacc)

length(unique(true_gene_gain_df$qacc)) 
#84 unique pgap annotation ids that identified as "gene gain"

#which derived isolates have genes gained
unique(str_extract(true_gene_gain_df$qacc, "[:digit:]+_[:digit:]+_[:alnum:]+")) 
#only "19_2_1" "15_2_7" have genes gained
```

Annotation and length of these genes gained.

```{r}
#load annotation files of the two derived isolates (19_2_1, 15_2_7) with genes gained
derived_annot <- vector("list", length=length(list.files(path = "./gene_gain_loss_analysis/pgap_method/derived_annotation"))) 
names(derived_annot) <- list.files(path = "./gene_gain_loss_analysis/pgap_method/derived_annotation")

for (i in 1:length(derived_annot)) {
  derived_annot[[i]] <- rtracklayer::import.gff3(paste0("./gene_gain_loss_analysis/pgap_method/derived_annotation/", names(derived_annot[i])))
}

derived_name <- str_extract(names(derived_annot), "[:digit:]+_[:digit:]+_[:alnum:]+")

for (i in seq_along(derived_annot)) {
  seqlevels(derived_annot[[i]]) <- unique(paste0(derived_name[i], "_", seqnames(derived_annot[[i]])))
} #rename the chromosome/plasmids to include the derived isolate name

derived_annot_grl <- GRangesList(derived_annot) #combine all 26 GRanges objects to 1 GRangesList object

derived_annot_gr <- unlist(derived_annot_grl) #unlist GRangesList object to a GRanges object

derived_annot_gr <- derived_annot_gr[mcols(derived_annot_gr)$type != "region" & mcols(derived_annot_gr)$type != "gene"] #remove rows with "region" in the "type" column which corresponds to the entire scaffold instead of genes and "gene" which shares the same range as "cds"

mcols(derived_annot_gr)$ID <- paste0(str_extract(as.vector(seqnames(derived_annot_gr)), "[:digit:]+_[:digit:]+_[:alnum:]+"), "_", mcols(derived_annot_gr)$ID) #ID is only unique for an isolate, add derived isolate's name to ID to make it unique across isolates

names(derived_annot_gr) <- 1:length(derived_annot_gr) #index the rows

derived_annot_df <- as.data.frame(derived_annot_gr) #convert to data frame

derived_annot_df <- cbind(index=as.numeric(rownames(derived_annot_df)), derived_annot_df) #index each row with row number starting from 1

#=========================================================================================

#filter to find the 84 pgap annotation ids identified as "gene gain"
true_gene_gain_annot_gr <- derived_annot_gr[mcols(derived_annot_gr)$ID %in% true_gene_gain_df$qacc]

names(true_gene_gain_annot_gr) <- 1:length(true_gene_gain_annot_gr) #index the rows

true_gene_gain_annot_df <- as.data.frame(true_gene_gain_annot_gr) #convert to data frame

#verify the number of features are 84
length(true_gene_gain_annot_gr)

#product of these genes
table(mcols(true_gene_gain_annot_gr)$product)

#length of these genes
summary(width(true_gene_gain_annot_gr))

true_gene_gain_annot_gr
```

What features are upstream and downstream of these genes gained. Use "precede" and "follow" functions in the "GenomicRanges" package.

Based on the documentation (`?GenomicRanges::precede`), for "precede", range 5-10 on plus strand (query) precedes range 15-18 on plus strand (subject), but range 20-25 on minus strand (query) precedes range 15-18 on minus strand (subject).

```{r}
query1 <- GRanges("A", IRanges(c(5, 20), width=6), strand="+")
query2 <- GRanges("A", IRanges(c(5, 20), width=6), strand="-")
subject <- GRanges("A", IRanges(rep(c(10, 15), 2), width=c(5,4)), strand=c("+", "+", "-", "-"))
query1
query2
subject

precede(query1, subject)
precede(query2, subject)
```

For "follow", range 20-25 on plus strand (query) follows range 15-18 on plus strand (subject), but range 5-10 on minus strand (query) follows range 15-18 on minus strand (subject).

```{r}
query1 <- GRanges("A", IRanges(c(5, 20), width=6), strand="+")
query2 <- GRanges("A", IRanges(c(5, 20), width=6), strand="-")
subject <- GRanges("A", IRanges(rep(c(10, 15), 2), width=c(5,4)), strand=c("+", "+", "-", "-"))
query1
query2
subject

follow(query1, subject)
follow(query2, subject)
```

"precede" and "follow" only works on the same strand, so ranges on a plus strand cannot precede or follow a range

Use true genes gained as query, derived isolate's annotation as subject.

Use "precede" and "follow" to find the single nearest annotations on each side of the genes gained.

```{r}
true_gene_gain_precede <- GenomicRanges::precede(true_gene_gain_annot_gr, subject=derived_annot_gr, select="first", ignore.strand=FALSE)

true_gene_gain_precede #there are duplicated indexes, meaning that some genes gained share the same nearest annotations.

true_gene_gain_precede_annot <- subset(derived_annot_df, index %in% true_gene_gain_precede) 
  
#product in these nearest annotations
table(true_gene_gain_precede_annot$product)
```

```{r}
true_gene_gain_follow <- GenomicRanges::follow(true_gene_gain_annot_gr, subject=derived_annot_gr, select="last", ignore.strand=FALSE)

true_gene_gain_follow #there are duplicated indexes, meaning that some genes gained share the same nearest annotations.

true_gene_gain_follow_annot <- subset(derived_annot_df, index %in% true_gene_gain_follow)

#product in these nearest annotations
table(true_gene_gain_follow_annot$product)
```

# Next step: plot all annotations on the scaffold where genes gained are located on

# Next step: align scaffold where the genes gained are located on to the MPA genomes to see if scaffolds are chromosome or plasmid. - Minimap2

# Next step: for those false positive BLAST hits not overlapping with annotations,

```{r}
sessionInfo()
```
